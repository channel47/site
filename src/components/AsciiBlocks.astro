---
/**
 * AsciiBlocks Component
 *
 * A dense field of ASCII block characters with visible wave interference.
 * Waves directly control character density and brightness.
 * Pulses add dramatic bursts of energy.
 *
 * The effect: flowing patterns of density that shift and morph,
 * with periodic bright pulses rippling through.
 */

interface Props {
  class?: string;
}

const { class: className } = Astro.props;
const canvasId = `ascii-blocks-${Math.random().toString(36).substr(2, 9)}`;
---

<div
  class={`ascii-blocks ${className || ''}`.trim()}
  data-ascii-blocks
>
  <canvas id={canvasId} class="ascii-blocks__canvas" aria-hidden="true"></canvas>
</div>

<script>
  // Block characters from sparse to dense
  const BLOCKS = ['·', '░', '▒', '▓', '█'];

  interface Cell {
    x: number;
    y: number;
    col: number;
    row: number;
    noisePhase: number;
    hue: number;
  }

  interface Pulse {
    x: number;
    y: number;
    startTime: number;
    strength: number;
    speed: number;
  }

  function initAsciiBlocks() {
    const containers = document.querySelectorAll('[data-ascii-blocks]');

    containers.forEach((container) => {
      if (container.hasAttribute('data-initialized')) return;
      container.setAttribute('data-initialized', 'true');

      const canvas = container.querySelector('canvas') as HTMLCanvasElement;
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // State
      let cells: Cell[] = [];
      let pulses: Pulse[] = [];
      let width = 0;
      let height = 0;
      let cols = 0;
      let rows = 0;
      let cellSize = 16;
      let animationId = 0;
      let isRunning = false;
      let startTime = 0;
      let lastPulseTime = 0;

      const config = {
        entranceDuration: 1600,
        pulseInterval: 6000,
        pulseSpeed: 0.055,
        pulseRadius: 450,
        baseOpacity: 0.25,
        peakOpacity: 0.95,
      };

      // Two dominant waves that create clear interference bands
      function getWaveValue(x: number, y: number, time: number): number {
        // Wave 1: Horizontal sweep (primary)
        const wave1 = Math.sin(x * 0.012 + time * 0.0008);

        // Wave 2: Diagonal sweep (creates interference)
        const wave2 = Math.sin((x * 0.8 + y * 0.6) * 0.01 + time * 0.0006);

        // Wave 3: Slow vertical undulation
        const wave3 = Math.sin(y * 0.015 + time * 0.0003) * 0.4;

        // Combine with interference (waves can reinforce or cancel)
        const combined = (wave1 + wave2 + wave3) / 2.4;

        // Map from [-1, 1] to [0, 1]
        return (combined + 1) / 2;
      }

      // Pulse creates expanding ring of energy
      function getPulseValue(x: number, y: number, time: number): number {
        let total = 0;

        for (const pulse of pulses) {
          const dx = x - pulse.x;
          const dy = y - pulse.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const elapsed = time - pulse.startTime;
          const ringRadius = elapsed * pulse.speed;
          const ringWidth = 60;

          // Distance from the ring edge
          const distFromRing = Math.abs(dist - ringRadius);

          if (distFromRing < ringWidth && dist < config.pulseRadius) {
            // Sharp ring falloff
            const ringIntensity = 1 - distFromRing / ringWidth;
            // Fade over time
            const timeFade = Math.max(0, 1 - elapsed / 3500);
            // Fade at edges
            const distFade = 1 - dist / config.pulseRadius;

            total += ringIntensity * ringIntensity * timeFade * distFade * pulse.strength;
          }
        }

        return Math.min(1, total);
      }

      function spawnPulse(time: number) {
        pulses.push({
          x: width * (0.15 + Math.random() * 0.7),
          y: height * (0.2 + Math.random() * 0.6),
          startTime: time,
          strength: 0.8 + Math.random() * 0.2,
          speed: config.pulseSpeed * (0.9 + Math.random() * 0.2),
        });

        // Clean old pulses
        pulses = pulses.filter(p => time - p.startTime < 4000);
      }

      function setupCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = Math.min(window.devicePixelRatio || 1, 2);

        width = rect.width;
        height = rect.height;

        // Responsive cell size
        if (rect.width < 480) {
          cellSize = 12;
        } else if (rect.width < 768) {
          cellSize = 14;
        } else if (rect.width < 1024) {
          cellSize = 16;
        } else {
          cellSize = 18;
        }

        cols = Math.ceil(rect.width / cellSize) + 1;
        rows = Math.ceil(rect.height / cellSize) + 1;

        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = `${rect.width}px`;
        canvas.style.height = `${rect.height}px`;

        ctx.scale(dpr, dpr);

        // Create cells
        cells = [];
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            cells.push({
              x: col * cellSize,
              y: row * cellSize,
              col,
              row,
              noisePhase: Math.random() * Math.PI * 2,
              hue: 28 + Math.random() * 14,
            });
          }
        }

        pulses = [];
      }

      function easeOutExpo(t: number): number {
        return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
      }

      function animate(timestamp: number) {
        if (!isRunning) return;

        if (startTime === 0) {
          startTime = timestamp;
          lastPulseTime = timestamp;
        }

        const time = timestamp - startTime;
        const entranceProgress = Math.min(1, easeOutExpo(time / config.entranceDuration));

        // Spawn pulses periodically
        if (time - lastPulseTime > config.pulseInterval && time > 600) {
          spawnPulse(time);
          lastPulseTime = time;
        }

        ctx.clearRect(0, 0, width, height);
        ctx.font = `${cellSize}px "Geist Mono", ui-monospace, monospace`;
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';

        for (const cell of cells) {
          const cx = cell.x + cellSize / 2;
          const cy = cell.y + cellSize / 2;

          // Get wave value (0-1) - this drives the base pattern
          const waveValue = getWaveValue(cx, cy, time);

          // Get pulse value (0-1) - adds bright bursts
          const pulseValue = getPulseValue(cx, cy, time);

          // Small per-cell shimmer
          const shimmer = Math.sin(time * 0.002 + cell.noisePhase) * 0.08;

          // Combined intensity
          const intensity = Math.min(1, waveValue + shimmer + pulseValue * 1.2);

          // Entrance animation (sweep from left)
          const entranceDelay = (cell.x / width) * 0.4;
          const cellEntrance = Math.max(0, Math.min(1,
            (entranceProgress - entranceDelay) / (1 - entranceDelay * 0.5)
          ));

          if (cellEntrance <= 0) continue;

          // Character based on intensity
          // Map intensity 0-1 to character index
          const charIndex = Math.min(BLOCKS.length - 1, Math.floor(intensity * BLOCKS.length));
          const char = BLOCKS[charIndex];

          // Opacity: wave creates visible variation, pulse boosts dramatically
          const baseOpacity = config.baseOpacity + (config.peakOpacity - config.baseOpacity) * (waveValue * 0.6);
          const finalOpacity = Math.min(1, baseOpacity + pulseValue * 0.7) * cellEntrance;

          // Color: warmer and brighter at higher intensity
          const saturation = 0.02 + intensity * 0.14;
          const lightness = 30 + intensity * 50;
          const hue = cell.hue + pulseValue * 15;

          ctx.fillStyle = `oklch(${lightness}% ${saturation} ${hue} / ${finalOpacity})`;
          ctx.fillText(char, cell.x, cell.y);

          // Extra glow layer for pulse peaks
          if (pulseValue > 0.4) {
            const glowOpacity = (pulseValue - 0.4) * 0.5 * cellEntrance;
            ctx.fillStyle = `oklch(80% 0.18 40 / ${glowOpacity})`;
            ctx.fillText(char, cell.x, cell.y);
          }
        }

        animationId = requestAnimationFrame(animate);
      }

      function start() {
        if (isRunning) return;
        isRunning = true;
        startTime = 0;
        animationId = requestAnimationFrame(animate);
      }

      function pause() {
        isRunning = false;
        cancelAnimationFrame(animationId);
      }

      function handleVisibility() {
        if (document.hidden) {
          pause();
        } else if (container.hasAttribute('data-visible')) {
          start();
        }
      }

      document.addEventListener('visibilitychange', handleVisibility);

      const resizeObserver = new ResizeObserver(() => {
        setupCanvas();
      });
      resizeObserver.observe(container);

      const intersectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              container.setAttribute('data-visible', 'true');
              start();
            } else {
              container.removeAttribute('data-visible');
              pause();
            }
          });
        },
        { threshold: 0.1 }
      );
      intersectionObserver.observe(container);

      // Wait for font to load before starting to avoid visual artifacts
      async function waitForFont() {
        try {
          await document.fonts.load('16px "Geist Mono"');
        } catch {
          // Font API not supported or font not found, proceed anyway
        }
        setupCanvas();
      }

      waitForFont();

      (container as HTMLElement & { destroy?: () => void }).destroy = () => {
        pause();
        resizeObserver.disconnect();
        intersectionObserver.disconnect();
        document.removeEventListener('visibilitychange', handleVisibility);
      };
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAsciiBlocks);
  } else {
    initAsciiBlocks();
  }

  document.addEventListener('astro:page-load', initAsciiBlocks);
</script>

<style>
  .ascii-blocks {
    position: relative;
    width: 100%;
    /* Generous height on mobile for visual impact */
    height: 180px;
    overflow: hidden;

    /* Softer fade on mobile for more breathing room */
    mask-image:
      linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%),
      linear-gradient(to right, transparent 0%, black 6%, black 94%, transparent 100%);
    mask-composite: intersect;
    -webkit-mask-image:
      linear-gradient(to bottom, transparent 0%, black 15%, black 85%, transparent 100%),
      linear-gradient(to right, transparent 0%, black 6%, black 94%, transparent 100%);
    -webkit-mask-composite: source-in;
  }

  @media (min-width: 375px) {
    .ascii-blocks {
      height: 200px;
    }
  }

  @media (min-width: 480px) {
    .ascii-blocks {
      height: 240px;
      /* Tighter fade on larger screens */
      mask-image:
        linear-gradient(to bottom, transparent 0%, black 12%, black 88%, transparent 100%),
        linear-gradient(to right, transparent 0%, black 4%, black 96%, transparent 100%);
      -webkit-mask-image:
        linear-gradient(to bottom, transparent 0%, black 12%, black 88%, transparent 100%),
        linear-gradient(to right, transparent 0%, black 4%, black 96%, transparent 100%);
    }
  }

  @media (min-width: 768px) {
    .ascii-blocks {
      height: 300px;
    }
  }

  @media (min-width: 1024px) {
    .ascii-blocks {
      height: 360px;
    }
  }

  @media (min-width: 1280px) {
    .ascii-blocks {
      height: 420px;
    }
  }

  .ascii-blocks__canvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  @media (prefers-reduced-motion: reduce) {
    .ascii-blocks__canvas {
      opacity: 0.35;
    }
  }
</style>
