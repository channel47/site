---
/**
 * DivergingPaths Component
 *
 * A canvas animation that visualizes "Same tools. Different outcomes."
 * Lines begin together on the left, traveling horizontally.
 * Most continue flat â€” a few gradually rise, separating from the pack.
 *
 * Metaphor: Everyone starts with the same tools/access.
 * Those who understand deeply take a different trajectory.
 * The gap widens over time.
 */

interface Props {
  class?: string;
}

const { class: className } = Astro.props;
const canvasId = `diverging-paths-${Math.random().toString(36).substr(2, 9)}`;
---

<div
  class={`diverging-paths ${className || ''}`.trim()}
  data-diverging-paths
>
  <canvas id={canvasId} class="diverging-paths__canvas" aria-hidden="true"></canvas>
</div>

<script>
  interface Line {
    y: number;           // Current Y position (relative to center)
    baseY: number;       // Starting Y offset from center
    divergence: number;  // How much this line diverges (0 = flat, positive = rises)
    speed: number;       // Horizontal travel speed
    opacity: number;     // Line opacity
    phase: number;       // Animation phase offset
    thickness: number;   // Line width
  }

  interface AnimationState {
    lines: Line[];
    width: number;
    height: number;
    time: number;
    animationId: number;
    isRunning: boolean;
    hasStarted: boolean;
    startTime: number;
  }

  function initDivergingPaths() {
    const containers = document.querySelectorAll('[data-diverging-paths]');

    containers.forEach((container) => {
      if (container.hasAttribute('data-initialized')) return;
      container.setAttribute('data-initialized', 'true');

      const canvas = container.querySelector('canvas') as HTMLCanvasElement;
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      // Get CSS custom properties
      const styles = getComputedStyle(document.documentElement);
      const accentColor = styles.getPropertyValue('--color-accent').trim() || 'oklch(68% 0.14 35)';

      // Configuration
      const config = {
        lineCount: 12,
        divergentCount: 3,         // How many lines diverge upward
        maxDivergence: 0.15,       // Maximum angle of divergence (as ratio of height)
        baseSpeed: 0.3,            // Base horizontal speed
        lineSpacing: 8,            // Vertical spacing between lines at origin
        trailLength: 0.7,          // How much of canvas width the trail covers
        entranceDuration: 1500,    // ms for lines to fade in
        accentColor,
      };

      // Animation state
      const state: AnimationState = {
        lines: [],
        width: 0,
        height: 0,
        time: 0,
        animationId: 0,
        isRunning: false,
        hasStarted: false,
        startTime: 0,
      };

      // Create lines
      function createLines() {
        state.lines = [];
        const centerY = 0; // Lines are relative to center

        // Calculate total height of line cluster
        const totalHeight = (config.lineCount - 1) * config.lineSpacing;
        const startY = -totalHeight / 2;

        // Determine which lines will diverge (pick from upper portion)
        const divergentIndices = new Set<number>();
        while (divergentIndices.size < config.divergentCount) {
          // Bias toward upper lines for divergence
          const index = Math.floor(Math.random() * (config.lineCount * 0.6));
          divergentIndices.add(index);
        }

        for (let i = 0; i < config.lineCount; i++) {
          const baseY = startY + i * config.lineSpacing;
          const isDivergent = divergentIndices.has(i);

          state.lines.push({
            y: baseY,
            baseY,
            divergence: isDivergent
              ? -(0.05 + Math.random() * config.maxDivergence) // Negative = rises (y decreases)
              : 0,
            speed: config.baseSpeed * (0.9 + Math.random() * 0.2),
            opacity: isDivergent ? 0.9 : 0.35 + Math.random() * 0.25,
            phase: Math.random() * Math.PI * 2,
            thickness: isDivergent ? 1.5 : 1,
          });
        }

        // Sort by divergence so divergent lines draw on top
        state.lines.sort((a, b) => Math.abs(a.divergence) - Math.abs(b.divergence));
      }

      // Handle DPI scaling
      function setupCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        state.width = rect.width;
        state.height = rect.height;

        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = `${rect.width}px`;
        canvas.style.height = `${rect.height}px`;

        ctx.scale(dpr, dpr);
        createLines();
      }

      // Easing function for entrance
      function easeOutCubic(t: number): number {
        return 1 - Math.pow(1 - t, 3);
      }

      // Draw a single line with gradient trail that flows continuously
      function drawLine(line: Line, entranceProgress: number) {
        const { width, height } = state;
        const centerY = height / 2;

        // Flow speed - lines move continuously from left to right
        const cycleDuration = 8000; // 8 seconds to complete one cycle
        const flowProgress = ((state.time * line.speed + line.phase * 1000) % cycleDuration) / cycleDuration;

        // Line length as portion of canvas width
        const lineLength = width * config.trailLength;

        // Calculate start and end X positions based on flow
        // Lines flow from off-screen left to off-screen right
        const totalTravel = width + lineLength;
        const headX = -lineLength * 0.2 + flowProgress * totalTravel;
        const tailX = headX - lineLength;

        // Only draw if visible
        if (headX < 0 || tailX > width) return;

        // Calculate Y position at each point along the line
        // Y diverges based on X position (normalized to canvas width)
        const points: { x: number; y: number }[] = [];
        const segments = 60;

        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const x = tailX + t * lineLength;

          // Skip points outside visible area
          if (x < -10 || x > width + 10) continue;

          // Divergence is based on how far across the canvas we are (0 to 1)
          // This means divergence accelerates as lines move right
          const canvasProgress = Math.max(0, x / width);
          const divergenceAmount = line.divergence * canvasProgress * canvasProgress * height;
          const y = centerY + line.baseY + divergenceAmount;

          points.push({ x, y });
        }

        if (points.length < 2) return;

        // Draw the line
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);

        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }

        // Create gradient for the line (tail fades, head is solid)
        const gradientStartX = Math.max(0, tailX);
        const gradientEndX = Math.min(width, headX);
        const gradient = ctx.createLinearGradient(gradientStartX, 0, gradientEndX, 0);
        const baseOpacity = line.opacity * entranceProgress;

        gradient.addColorStop(0, `oklch(68% 0.14 35 / 0)`);
        gradient.addColorStop(0.4, `oklch(68% 0.14 35 / ${baseOpacity * 0.4})`);
        gradient.addColorStop(0.8, `oklch(68% 0.14 35 / ${baseOpacity * 0.85})`);
        gradient.addColorStop(1, `oklch(68% 0.14 35 / ${baseOpacity})`);

        ctx.strokeStyle = gradient;
        ctx.lineWidth = line.thickness;
        ctx.lineCap = 'round';
        ctx.stroke();

        // Draw a brighter head point for divergent lines
        if (line.divergence !== 0 && headX > 0 && headX < width) {
          const head = points[points.length - 1];
          if (head) {
            ctx.beginPath();
            ctx.arc(head.x, head.y, 2.5, 0, Math.PI * 2);
            ctx.fillStyle = `oklch(80% 0.14 45 / ${baseOpacity})`;
            ctx.fill();
          }
        }
      }

      // Main animation loop
      function animate(timestamp: number) {
        if (!state.isRunning) return;

        if (!state.hasStarted) {
          state.startTime = timestamp;
          state.hasStarted = true;
        }

        state.time = timestamp - state.startTime;

        // Calculate entrance progress (0 to 1 over entrance duration)
        const entranceProgress = Math.min(1, easeOutCubic(state.time / config.entranceDuration));

        // Clear canvas
        ctx.clearRect(0, 0, state.width, state.height);

        // Draw all lines
        state.lines.forEach((line) => {
          drawLine(line, entranceProgress);
        });

        state.animationId = requestAnimationFrame(animate);
      }

      // Start animation
      function start() {
        if (state.isRunning) return;
        state.isRunning = true;
        state.hasStarted = false;
        state.animationId = requestAnimationFrame(animate);
      }

      // Pause animation
      function pause() {
        state.isRunning = false;
        cancelAnimationFrame(state.animationId);
      }

      // Handle visibility changes
      function handleVisibility() {
        if (document.hidden) {
          pause();
        } else if (container.hasAttribute('data-visible')) {
          start();
        }
      }

      document.addEventListener('visibilitychange', handleVisibility);

      // Handle resize
      const resizeObserver = new ResizeObserver(() => {
        setupCanvas();
      });
      resizeObserver.observe(container);

      // Intersection observer to start animation when visible
      const intersectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              container.setAttribute('data-visible', 'true');
              start();
            } else {
              container.removeAttribute('data-visible');
              pause();
            }
          });
        },
        { threshold: 0.2 }
      );
      intersectionObserver.observe(container);

      // Initial setup
      setupCanvas();

      // Cleanup function (exposed for potential external use)
      (container as HTMLElement & { destroy?: () => void }).destroy = () => {
        pause();
        resizeObserver.disconnect();
        intersectionObserver.disconnect();
        document.removeEventListener('visibilitychange', handleVisibility);
      };
    });
  }

  // Initialize on load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initDivergingPaths);
  } else {
    initDivergingPaths();
  }

  // Also run on Astro view transitions
  document.addEventListener('astro:page-load', initDivergingPaths);
</script>

<style>
  .diverging-paths {
    position: relative;
    width: 100%;
    height: 80px;
    overflow: hidden;

    /* Subtle mask for left/right fade */
    mask-image: linear-gradient(
      to right,
      transparent 0%,
      black 8%,
      black 92%,
      transparent 100%
    );
    -webkit-mask-image: linear-gradient(
      to right,
      transparent 0%,
      black 8%,
      black 92%,
      transparent 100%
    );
  }

  @media (min-width: 768px) {
    .diverging-paths {
      height: 110px;
    }
  }

  @media (min-width: 1024px) {
    .diverging-paths {
      height: 130px;
    }
  }

  @media (min-width: 1280px) {
    .diverging-paths {
      height: 150px;
    }
  }

  .diverging-paths__canvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  /* Reduced motion: show static state */
  @media (prefers-reduced-motion: reduce) {
    .diverging-paths__canvas {
      opacity: 0.5;
    }
  }
</style>
