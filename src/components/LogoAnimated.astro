---
/**
 * LogoAnimated Component
 *
 * The "47" logo with a character scramble → lock-in animation.
 * Characters cycle through random Unicode blocks before settling
 * into their final form, creating a "tuning into a signal" effect.
 */

interface Props {
  class?: string;
  delay?: number; // Animation start delay in ms
}

const { class: className, delay = 0 } = Astro.props;
---

<span
  class={`logo-animated ${className || ''}`.trim()}
  role="img"
  aria-label="Channel47 Logo"
  data-logo-animated
  data-delay={delay}
>
  <span class="logo-animated__glyph" aria-hidden="true">
    <span class="logo-animated__line" data-target="█ █ ▀▀█">
      <span class="logo-animated__char" data-char="█"></span>
      <span class="logo-animated__char" data-char=" "></span>
      <span class="logo-animated__char" data-char="█"></span>
      <span class="logo-animated__char" data-char=" "></span>
      <span class="logo-animated__char" data-char="▀"></span>
      <span class="logo-animated__char" data-char="▀"></span>
      <span class="logo-animated__char" data-char="█"></span>
    </span>
    <span class="logo-animated__line" data-target="▀▀█  █">
      <span class="logo-animated__char" data-char="▀"></span>
      <span class="logo-animated__char" data-char="▀"></span>
      <span class="logo-animated__char" data-char="█"></span>
      <span class="logo-animated__char" data-char=" "></span>
      <span class="logo-animated__char" data-char=" "></span>
      <span class="logo-animated__char" data-char="█"></span>
    </span>
  </span>
</span>

<script>
  // Run immediately and also on page load for Astro view transitions
  function initLogoAnimations() {
    const logos = document.querySelectorAll('[data-logo-animated]');

    // Unicode block characters for scrambling
    const GLYPHS = ['█', '▓', '▒', '░', '▀', '▄', '▌', '▐', '■', '□', '▪', '▫', '◼', '◻', '▰', '▱'];

    logos.forEach((logo) => {
      if (logo.hasAttribute('data-initialized')) return;
      logo.setAttribute('data-initialized', 'true');

      const delay = parseInt(logo.getAttribute('data-delay') || '0', 10);
      const chars = logo.querySelectorAll('.logo-animated__char') as NodeListOf<HTMLElement>;

      // Store final characters and set initial random state
      const targets: string[] = [];
      chars.forEach((char) => {
        targets.push(char.dataset.char || ' ');
        // Start with random character (or space stays space)
        if (char.dataset.char !== ' ') {
          char.textContent = GLYPHS[Math.floor(Math.random() * GLYPHS.length)];
        } else {
          char.textContent = ' ';
        }
      });

      // Animation state
      const locked: boolean[] = new Array(chars.length).fill(false);
      let scrambleInterval: number;
      let hasAnimated = false;

      // Scramble non-locked, non-space characters
      function scramble() {
        chars.forEach((char, i) => {
          if (!locked[i] && targets[i] !== ' ') {
            char.textContent = GLYPHS[Math.floor(Math.random() * GLYPHS.length)];
          }
        });
      }

      // Lock in a single character with effect
      function lockChar(index: number) {
        locked[index] = true;
        const char = chars[index];
        char.textContent = targets[index];
        char.classList.add('is-locked');

        // Brief flash effect
        char.classList.add('is-flashing');
        setTimeout(() => char.classList.remove('is-flashing'), 100);
      }

      // Complete animation
      function complete() {
        clearInterval(scrambleInterval);
        logo.classList.add('is-complete');
      }

      // Schedule eased lock-in sequence and return timeout IDs
      function scheduleLockIns(
        lockDuration: number,
        baseDelay: number,
        onComplete: () => void
      ): number[] {
        const nonSpaceIndices = targets
          .map((t, i) => (t !== ' ' ? i : -1))
          .filter((i) => i !== -1);
        const shuffled = [...nonSpaceIndices].sort(() => Math.random() - 0.5);
        const timeouts: number[] = [];

        shuffled.forEach((charIndex, i) => {
          const progress = i / shuffled.length;
          const eased = 1 - Math.pow(1 - progress, 2);
          const lockTime = baseDelay + eased * lockDuration;

          const t = window.setTimeout(() => {
            lockChar(charIndex);
            if (i === shuffled.length - 1) onComplete();
          }, lockTime);
          timeouts.push(t);
        });

        return timeouts;
      }

      function beginScramble() {
        logo.classList.add('is-animating');
        scrambleInterval = window.setInterval(scramble, 50);
      }

      // Start the scramble animation
      function startAnimation() {
        if (hasAnimated) return;
        hasAnimated = true;

        setTimeout(() => {
          beginScramble();
          scheduleLockIns(800, 300, () => setTimeout(complete, 150));
        }, delay);
      }

      // Hover replay — faster scramble -> lock after initial animation
      let isReplaying = false;
      let replayTimeouts: number[] = [];

      function replayAnimation() {
        if (isReplaying) return;
        isReplaying = true;

        replayTimeouts.forEach((t) => clearTimeout(t));
        replayTimeouts = [];

        clearInterval(scrambleInterval);
        logo.classList.remove('is-complete');
        locked.fill(false);
        chars.forEach((char) => char.classList.remove('is-locked'));

        beginScramble();
        replayTimeouts = scheduleLockIns(400, 100, () => {
          const t = window.setTimeout(() => {
            complete();
            isReplaying = false;
          }, 100);
          replayTimeouts.push(t);
        });
      }

      logo.addEventListener('mouseenter', () => {
        if (!hasAnimated || isReplaying) return;
        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
        replayAnimation();
      });

      // Use Intersection Observer to trigger animation when visible
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              startAnimation();
              observer.disconnect();
            }
          });
        },
        { threshold: 0.5 }
      );

      observer.observe(logo);
    });
  }

  // Run on initial load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initLogoAnimations);
  } else {
    initLogoAnimations();
  }

  // Also run on Astro view transitions
  document.addEventListener('astro:page-load', initLogoAnimations);
</script>

<style>
  .logo-animated {
    --logo-glow: rgba(231, 229, 228, 0.3);

    position: relative;
    display: inline-flex;
    flex-direction: column;
    font-family: var(--font-family-mono);
    font-size: 11px;
    line-height: 1;
    font-weight: normal;
    color: var(--color-bone);
    white-space: pre;
    user-select: none;
    letter-spacing: -0.08em;
    cursor: pointer;
    text-shadow: 0 0 8px rgba(231, 229, 228, 0.15);
  }

  .logo-animated__glyph {
    display: flex;
    flex-direction: column;
    position: relative;
    z-index: 1;
  }

  .logo-animated__line {
    display: flex;
    height: 1.1em;
  }

  .logo-animated__char {
    display: inline-block;
    min-width: 0.55em;
    text-align: center;
    opacity: 0.3;
    transition: opacity 0.1s ease-out;
  }

  /* During animation - scrambling characters visible */
  .logo-animated.is-animating .logo-animated__char:not(.is-locked) {
    opacity: 0.5;
  }

  /* Locked characters are solid */
  .logo-animated__char.is-locked {
    opacity: 1;
  }

  /* Flash on lock-in */
  .logo-animated__char.is-flashing {
    text-shadow:
      0 0 6px var(--logo-glow),
      0 0 12px rgba(245, 158, 11, 0.25);
  }

  /* Completed state - glow with breathing animation */
  .logo-animated.is-complete .logo-animated__glyph {
    text-shadow:
      0 0 1px var(--logo-glow),
      0 0 8px var(--logo-glow);
    animation: logo-breathe 4s ease-in-out infinite;
    animation-delay: 1s;
  }

  @keyframes logo-breathe {
    0%, 100% {
      text-shadow:
        0 0 1px var(--logo-glow),
        0 0 8px var(--logo-glow);
    }
    50% {
      text-shadow:
        0 0 2px var(--logo-glow),
        0 0 12px var(--logo-glow),
        0 0 20px rgba(231, 229, 228, 0.18);
    }
  }

  /* Reduced motion - skip scramble, just fade in */
  @media (prefers-reduced-motion: reduce) {
    .logo-animated__char {
      opacity: 1 !important;
      transition: none;
    }

    .logo-animated__char.is-flashing {
      color: inherit;
      text-shadow: none;
    }

    .logo-animated.is-complete .logo-animated__glyph {
      animation: none;
    }
  }
</style>
